/*
 * NullHandlingExtensions
 *
 * Copyright (c) 2019 Takahisa YAMASHIGE
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/mit-license.php
 */

using System;

namespace MinimalTools.Extensions.NullHandling
{
    /// <summary>
    /// Extension methods for null handling.    
    /// </summary>
    public static class NullHandlingExtensions
    {
        /// <summary>
        /// Execute an action.
        /// </summary>
        /// <typeparam name="T">A type of the value.</typeparam>
        /// <param name="arg">The value.</param>
        /// <param name="action">An action to be invoked.</param>
        /// <exception cref="ArgumentNullException">action</exception>
        /// <remarks>
        /// It is useful to use this method with the null conditional operator.
        /// usage:
        ///  [not to use]
        /// 
        ///     if (arg != null)
        ///     {
        ///         list.Add(arg);
        ///     }
        /// 
        ///  [to use]
        /// 
        ///     arg?.Exec(list.Add);
        /// 
        /// </remarks>
        public static void Exec<T>(this T arg, Action<T> action)
        {
            if (action == null) throw new ArgumentNullException(nameof(action));
            action(arg);
        }


        /// <summary>
        /// Execute an action with two arguments.
        /// </summary>
        /// <typeparam name="T">A type of the value.</typeparam>
        /// <typeparam name="V">A type of the value that second argument.</typeparam>
        /// <param name="arg">The value.</param>
        /// <param name="action">An action to be invoked.</param>
        /// <param name="value">the secondary value.</param>
        /// <exception cref="ArgumentNullException">action</exception>
        /// <remarks>
        /// It is useful to use this method with the null conditional operator.
        /// usage:
        /// 
        ///  [not in use]
        /// 
        ///     if (arg != null)
        ///     {
        ///         arg.Text = text;
        ///     }
        /// 
        ///  [in use]
        /// 
        ///     arg?.Exec((a,v) => a.Text = v, text);
        ///     
        /// Even Exec(Action&lt;T&gt;) can do the same thing with the closure, so it will not force you to use it.
        /// </remarks>
        public static void Exec<T, V>(this T arg, Action<T, V> action, V value)
        {
            if (action == null) throw new ArgumentNullException(nameof(action));
            action(arg, value);
        }


        /// <summary>
        /// When argument is null, replaces null with alternative value.
        /// </summary>
        /// <typeparam name="T">A type of the value.</typeparam>
        /// <param name="arg">The value.</param>
        /// <param name="alternateValue">An alternative value that replaced when <paramref name="arg"/> is null.</param>
        /// <returns>If <paramref name="arg"/> is not null, returns the value, otherwise an alternative value.</returns>
        /// <remarks>
        /// If used instead of the null coalescing operator, there is an effect to make it easier to see, but my favorite problem.
        /// When replacing null with FirstOrDefault() at the end of long method chain, it makes a little mistake
        /// e.g.
        /// [not in use]
        ///     Foo obj = collection.Where..(omisson)...FirstOrDefault() ?? new Foo();
        /// [in use]
        ///     Foo obj = collection.Where..(omisson)....FirstOrDefault().OrElse(new Foo());
        /// </remarks>
        public static T OrElse<T>(this T arg, T alternateValue) => arg != null ? arg : alternateValue;


        /// <summary>
        /// When argument is null, replaces null with alternative value generated by <paramref name="supplier"/>.
        /// </summary>
        /// <typeparam name="T">A type of the value.</typeparam>
        /// <param name="arg">The value.</param>
        /// <param name="supplier">A delegate to generate the value that replaced when <paramref name="arg"/> is null.</param>
        /// <returns>If <paramref name="arg"/> is not null, returns the value, otherwise an alternative value.</returns>
        /// <exception cref="ArgumentNullException">supplier</exception>
        public static T OrElse<T>(this T arg, Func<T> supplier)
        {
            if (supplier == null) throw new ArgumentNullException(nameof(supplier));
            return arg != null ? arg : supplier();
        }


        /// <summary>
        /// When argument is null, throw exception.
        /// </summary>
        /// <typeparam name="T">A type of the value.</typeparam>
        /// <typeparam name="X">A type of value.</typeparam>
        /// <param name="arg">The value.</param>
        /// <param name="e">An exception thrown when <paramref name="arg"/> is null.</param>
        /// <returns>The value.</returns>
        public static T OrThrow<T, X>(this T arg, X e) where X : Exception => arg != null ? arg : throw e;


        /// <summary>
        /// When argument is null, throw exception generated by <paramref name="exceptionSupplier"/>.
        /// </summary>
        /// <typeparam name="T">A type of the value.</typeparam>
        /// <typeparam name="X">A type of value.</typeparam>
        /// <param name="arg">The value.</param>
        /// <param name="exceptionSupplier">A delegate to generate exception that thrown when <paramref name="arg"/> is null.</param>
        /// <returns>The value.</returns>
        /// <exception cref="ArgumentException">exceptionSupplier</exception>
        public static T OrThrow<T, X>(this T arg, Func<X> exceptionSupplier) where X : Exception
        {
            if (exceptionSupplier == null) throw new ArgumentNullException(nameof(exceptionSupplier));
            if (arg != null) return arg;
            else throw exceptionSupplier();
        }
    }
}